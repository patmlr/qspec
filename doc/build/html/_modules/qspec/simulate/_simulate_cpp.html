<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>qspec.simulate._simulate_cpp &mdash; qspec 30.05.2024 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" href="../../../_static/css/borders.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/wy-nav-content.css" type="text/css" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=861d89a9"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            qspec
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">qspec</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">qspec</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">qspec.simulate._simulate_cpp</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for qspec.simulate._simulate_cpp</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">qspec._simulate_cpp</span>
<span class="sd">===================</span>

<span class="sd">Classes and methods for the &#39;simulate&#39; module using the Python/C++ interface.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">qspec._types</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">qspec._cpp</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">qspec</span> <span class="kn">import</span> <span class="n">tools</span>
<span class="kn">from</span> <span class="nn">qspec</span> <span class="kn">import</span> <span class="n">get_f</span><span class="p">,</span> <span class="n">get_m</span>
<span class="kn">import</span> <span class="nn">qspec.algebra</span> <span class="k">as</span> <span class="nn">al</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Polarization&#39;</span><span class="p">,</span> <span class="s1">&#39;Laser&#39;</span><span class="p">,</span> <span class="s1">&#39;Environment&#39;</span><span class="p">,</span> <span class="s1">&#39;construct_electronic_state&#39;</span><span class="p">,</span> <span class="s1">&#39;construct_hyperfine_state&#39;</span><span class="p">,</span> <span class="s1">&#39;State&#39;</span><span class="p">,</span>
           <span class="s1">&#39;DecayMap&#39;</span><span class="p">,</span> <span class="s1">&#39;Atom&#39;</span><span class="p">,</span> <span class="s1">&#39;Interaction&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">sr_generate_y</span><span class="p">(</span><span class="n">denominator</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">f_theta</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">f_phi</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                  <span class="n">counts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param denominator: The denominator of the scattering rate.</span>
<span class="sd">    :param f_theta: The numerator with the &#39;theta-polarization&#39;.</span>
<span class="sd">    :param f_phi: The numerator with the &#39;phi-polarization&#39;.</span>
<span class="sd">    :param counts: The number of summands.</span>
<span class="sd">    :param shape: The shape of y.</span>
<span class="sd">    :returns: The scattering rate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>  <span class="c1"># Allocate memory.</span>
    <span class="n">denominator_p</span> <span class="o">=</span> <span class="n">denominator</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_complex_p</span><span class="p">)</span>  <span class="c1"># Get all pointers to the first elements of the arrays.</span>
    <span class="n">f_theta_p</span> <span class="o">=</span> <span class="n">f_theta</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_complex_p</span><span class="p">)</span>
    <span class="n">f_phi_p</span> <span class="o">=</span> <span class="n">f_phi</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_complex_p</span><span class="p">)</span>
    <span class="n">counts_p</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_int_p</span><span class="p">)</span>
    <span class="n">shape_p</span> <span class="o">=</span> <span class="n">shape</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_int_p</span><span class="p">)</span>
    <span class="n">y_p</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_double_p</span><span class="p">)</span>
    <span class="n">dll</span><span class="o">.</span><span class="n">sr_generate_y</span><span class="p">(</span><span class="n">denominator_p</span><span class="p">,</span> <span class="n">f_theta_p</span><span class="p">,</span> <span class="n">f_phi_p</span><span class="p">,</span> <span class="n">counts_p</span><span class="p">,</span> <span class="n">shape_p</span><span class="p">,</span> <span class="n">y_p</span><span class="p">)</span>  <span class="c1"># Modify y &quot;in-place&quot; with C++.</span>
    <span class="k">return</span> <span class="n">y</span>


<span class="k">def</span> <span class="nf">_process_q_axis</span><span class="p">(</span><span class="n">q_axis</span><span class="p">:</span> <span class="n">array_like</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Preprocess the quantization axis.</span>

<span class="sd">    :param q_axis: The quantization axis. Must be an integer in {0, 1, 2} or a 3d-vector.</span>
<span class="sd">    :returns: The quantization axis as a 3d-vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">q_axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">q_axis</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">q_axis</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;q_axis must be an integer or a 3d-vector.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">int</span><span class="p">(</span><span class="n">q_axis</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;q_axis must be in {0, 1, 2}.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">q_axis</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">unit_vector</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">q_axis</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">q_axis</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;q_axis must be an integer or a 3d-vector.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">q_axis</span>


<div class="viewcode-block" id="Polarization"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Polarization">[docs]</a><span class="k">class</span> <span class="nc">Polarization</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class representing a polarization state of light. The property &#39;x&#39; holds the polarization in cartesian coordinates.</span>
<span class="sd">    The property &#39;q&#39; holds the polarization in spherical coordinates ( sigma-, pi, sigma+ )</span>
<span class="sd">    with respect to the chosen quantization axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">:</span> <span class="n">array_iter</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">q_axis</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">vec_as_q</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param vec: The polarization vector. I.e. the amplitude of the electromagnetic wave. So to specify, e.g.,</span>
<span class="sd">         1/3 of pi and 2/3 sigma+ light for a given &#39;q_axis&#39;, vec must be ( 0, sqrt(1/3), sqrt(2/3) ).</span>
<span class="sd">         The default is linear polarization in z-direction, such that x = (0, 0, 1) and q = (0, 1, 0).</span>
<span class="sd">        :param q_axis: The quantization axis. Must be an integer in {0, 1, 2} or a 3d-vector. The default is 2 (z-axis).</span>
<span class="sd">        :param vec_as_q: Whether &#39;vec&#39; is given as ( sigma-, pi, sigma+ ) (True) or in cartesian coordinates (False).</span>
<span class="sd">        :param instance: A pointer to an existing Polarization instance.</span>
<span class="sd">         If this is specified, the other parameters are omitted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">instance</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">dll</span><span class="o">.</span><span class="n">polarization_construct</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">vec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">unit_vector</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">vec</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;vec must be a 3d-vector.&#39;</span><span class="p">)</span>

            <span class="n">q_axis</span> <span class="o">=</span> <span class="n">_process_q_axis</span><span class="p">(</span><span class="n">q_axis</span><span class="p">)</span>
            <span class="n">dll</span><span class="o">.</span><span class="n">polarization_init</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">q_axis</span><span class="p">,</span> <span class="n">vec_as_q</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">polarization_destruct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

<div class="viewcode-block" id="Polarization.def_q_axis"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Polarization.def_q_axis">[docs]</a>    <span class="k">def</span> <span class="nf">def_q_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q_axis</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">q_fixed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Defines the quantization axis. This changes either &#39;x&#39; or &#39;q&#39;, depending on &#39;q_fixed&#39;.</span>

<span class="sd">        :param q_axis: The quantization axis. Must be an integer in {0, 1, 2} or a 3d-vector. The default is 2 (z-axis).</span>
<span class="sd">        :param q_fixed: Whether &#39;q&#39; should stay the same with the new quantization axis (True) or &#39;x&#39; (False).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">q_axis</span> <span class="o">=</span> <span class="n">_process_q_axis</span><span class="p">(</span><span class="n">q_axis</span><span class="p">)</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">polarization_def_q_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">q_axis</span><span class="p">,</span> <span class="n">q_fixed</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">q_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The complex polarization in spherical coordinates ( sigma-, pi, sigma+ ).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">polarization_get_q_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The complex polarization in cartesian coordinates ( x, y, z ).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">polarization_get_x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">q</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The complex polarization in spherical coordinates ( sigma-, pi, sigma+ ).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">polarization_get_q</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span></div>


<div class="viewcode-block" id="Laser"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Laser">[docs]</a><span class="k">class</span> <span class="nc">Laser</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class representing a laser.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">:</span> <span class="n">scalar</span><span class="p">,</span> <span class="n">intensity</span><span class="p">:</span> <span class="n">scalar</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">polarization</span><span class="p">:</span> <span class="n">Polarization</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">k</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param freq: The frequency of the laser (MHz).</span>
<span class="sd">        :param intensity: The intensity of the laser (uW / mm**2 = W / m**2).</span>
<span class="sd">        :param polarization: The polarization of the laser.</span>
<span class="sd">        :param k: The direction of the laser.</span>
<span class="sd">        :param instance: A pointer to an existing Laser instance.</span>
<span class="sd">         If this is specified, the other parameters are omitted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">instance</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">dll</span><span class="o">.</span><span class="n">laser_construct</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_polarization</span> <span class="o">=</span> <span class="n">polarization</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_polarization</span> <span class="o">=</span> <span class="n">Polarization</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">unit_vector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Interaction.k must be a 3d-vector, but has shape </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="n">dll</span><span class="o">.</span><span class="n">laser_init</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">c_double</span><span class="p">(</span><span class="n">intensity</span><span class="p">),</span> <span class="n">polarization</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span>
                           <span class="n">k</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_double_p</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_polarization</span> <span class="o">=</span> <span class="n">Polarization</span><span class="p">(</span><span class="n">instance</span><span class="o">=</span><span class="n">dll</span><span class="o">.</span><span class="n">laser_get_polarization</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">laser_destruct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The frequency of the laser.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">laser_get_freq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@freq</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">freq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">scalar</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: The new frequency of the laser.</span>
<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">laser_set_freq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intensity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The intensity of the laser.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">laser_get_intensity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@intensity</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">intensity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">scalar</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: The new intensity of the laser.</span>
<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">laser_set_intensity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">polarization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The polarization of the laser.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polarization</span>

    <span class="nd">@polarization</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">polarization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Polarization</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: The new polarization of the laser.</span>
<span class="sd">        :return: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_polarization</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">laser_set_polarization</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">k</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The direction of the laser. The default direction is ( 1, 0, 0 ).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">laser_get_k</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@k</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">k</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">array_like</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: The new direction of the laser.</span>
<span class="sd">        :return: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_value</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Interaction.k must be a 3d-vector, but has shape </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_value</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">laser_set_k</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">_value</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span></div>


<span class="k">def</span> <span class="nf">_process_hyper_const</span><span class="p">(</span><span class="n">hyper_const</span><span class="p">:</span> <span class="n">array_like</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Preprocess the hyperfine-structure constants.</span>

<span class="sd">    :param hyper_const: The hyperfine-structure constants. Currently, constants up to the electric quadrupole order are</span>
<span class="sd">     supported (A, B). If &#39;hyper_const&#39; is a scalar,</span>
<span class="sd">     it is assumed to be the constant A and the other orders are 0 (MHz).</span>
<span class="sd">    :returns: The hyperfine-structure constants as a 3d-vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">hyper_const</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">hyper_const</span><span class="p">:</span>
        <span class="n">hyper_const</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hyper_const</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="n">hyper_const</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">hyper_const</span><span class="p">),</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
    <span class="n">hyper_const</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hyper_const</span><span class="p">)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">hyper_const</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">hyper_const</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hyper_const</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span>


<span class="c1"># noinspection PyPep8Naming</span>
<div class="viewcode-block" id="Environment"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Environment">[docs]</a><span class="k">class</span> <span class="nc">Environment</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class representing an electromagnetic environment.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">instance</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">dll</span><span class="o">.</span><span class="n">environment_construct</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">E</span> <span class="o">=</span> <span class="n">E</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">B</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">environment_destruct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">E</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">environment_get_E</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span> <span class="o">*</span> <span class="n">dll</span><span class="o">.</span><span class="n">environment_get_e_E</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>
    
    <span class="nd">@E</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">E</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">array_like</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dll</span><span class="o">.</span><span class="n">environment_set_E</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
            <span class="n">dll</span><span class="o">.</span><span class="n">environment_set_E_double</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="mf">0.</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">dll</span><span class="o">.</span><span class="n">environment_set_E_double</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">):</span>
                <span class="n">dll</span><span class="o">.</span><span class="n">environment_set_E</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;E must be a scalar, 3d-vector or None, but has shape </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">B</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">environment_get_B</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span> <span class="o">*</span> <span class="n">dll</span><span class="o">.</span><span class="n">environment_get_e_B</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>
    
    <span class="nd">@B</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">B</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">array_like</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dll</span><span class="o">.</span><span class="n">environment_set_B</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
            <span class="n">dll</span><span class="o">.</span><span class="n">environment_set_B_double</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="mf">0.</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">dll</span><span class="o">.</span><span class="n">environment_set_B_double</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">):</span>
                <span class="n">dll</span><span class="o">.</span><span class="n">environment_set_B</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;B must be a scalar, 3d-vector or None, but has shape </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span></div>


<div class="viewcode-block" id="State"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.State">[docs]</a><span class="k">class</span> <span class="nc">State</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class representing an atomic quantum state :math:`|(\\mathrm{label})SLJIFm\\rangle`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq_j</span><span class="p">:</span> <span class="n">scalar</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">scalar</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="n">scalar</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">scalar</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">scalar</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="n">scalar</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">scalar</span><span class="p">,</span>
                 <span class="n">hyper_const</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="n">scalar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param freq_j: The energetic position of the state without the hyperfine structure or the environment (MHz).</span>
<span class="sd">        :param s: The electron spin quantum number S.</span>
<span class="sd">        :param l: The electronic angular momentum quantum number L.</span>
<span class="sd">        :param j: The electronic total angular momentum quantum number J.</span>
<span class="sd">        :param i: The nuclear spin quantum number I.</span>
<span class="sd">        :param f: The total angular momentum quantum number F.</span>
<span class="sd">        :param m: The B-field-axis component quantum number m of the total angular momentum.</span>
<span class="sd">        :param hyper_const: The hyperfine-structure constants. Currently, constants up to the electric quadrupole order</span>
<span class="sd">         are supported (A, B). If &#39;hyper_const&#39; is a scalar, it is assumed to be the constant A</span>
<span class="sd">         and the other orders are 0 (MHz).</span>
<span class="sd">        :param g: The nuclear g-factor.</span>
<span class="sd">        :param label: The label of the state. The label is used to link states via decay maps.</span>
<span class="sd">        :param instance: A pointer to an existing State instance.</span>
<span class="sd">         If this is specified, the other parameters are omitted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">instance</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tools</span><span class="o">.</span><span class="n">check_half_integer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">hyper_const</span> <span class="o">=</span> <span class="n">_process_hyper_const</span><span class="p">(</span><span class="n">hyper_const</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">freq_j</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">dll</span><span class="o">.</span><span class="n">state_construct</span><span class="p">()</span>
            <span class="n">dll</span><span class="o">.</span><span class="n">state_init</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="n">freq_j</span><span class="p">),</span> <span class="n">c_double</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">c_double</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">c_double</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">c_double</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                           <span class="n">c_double</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">c_double</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">hyper_const</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="n">c_char_p</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)))</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">state_destruct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">, &#39;</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> \
            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">tools</span><span class="o">.</span><span class="n">half_integer_to_str</span><span class="p">(</span><span class="n">qn</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">qn</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">]])</span>

<div class="viewcode-block" id="State.update"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.State.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the shifted frequency of the state.</span>

<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">environment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dll</span><span class="o">.</span><span class="n">state_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dll</span><span class="o">.</span><span class="n">state_update_env</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">environment</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span></div>

<div class="viewcode-block" id="State.get_shift"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.State.get_shift">[docs]</a>    <span class="k">def</span> <span class="nf">get_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The difference between the shifted frequency of the hyperfine-structure</span>
<span class="sd">         and the frequency of the fine-structure state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">state_get_shift</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">freq_j</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The frequency of the fine-structure state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">state_get_freq_j</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@freq_j</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">freq_j</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">scalar</span><span class="p">):</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">state_set_freq_j</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The shifted frequency of the hyperfine-structure state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">state_get_freq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">s</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The electron spin quantum number S.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">state_get_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">l</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The electronic angular momentum quantum number L.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">state_get_l</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">j</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The electronic total angular momentum quantum number J.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">state_get_j</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">i</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The nuclear spin quantum number I.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">state_get_i</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The total angular momentum quantum number F.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">state_get_f</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The B-field-axis component quantum number m of the total angular momentum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">state_get_m</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hyper_const</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The hyperfine-structure constants as a 3d-vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">state_get_hyper_const</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@hyper_const</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">hyper_const</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">array_like</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: The new hyperfine-structure constants. Currently, constants up to the electric quadrupole order</span>
<span class="sd">         are supported (A, B). If &#39;hyper_const&#39; is a scalar, it is assumed to be the constant A</span>
<span class="sd">         and the other orders are 0 (MHz).</span>
<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">_process_hyper_const</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">state_get_hyper_const</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The nuclear g-factor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">state_get_g</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@g</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">scalar</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: The new nuclear g-factor.</span>
<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">state_set_g</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The label of the state. The label is used to link states via decay maps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">state_get_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>

    <span class="nd">@label</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: The label of the state. The label is used to link states via decay maps.</span>
<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">state_set_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)))</span></div>


<div class="viewcode-block" id="construct_electronic_state"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.construct_electronic_state">[docs]</a><span class="k">def</span> <span class="nf">construct_electronic_state</span><span class="p">(</span><span class="n">freq_0</span><span class="p">:</span> <span class="n">scalar</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">scalar</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="n">scalar</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">scalar</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">scalar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                               <span class="n">hyper_const</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">scalar</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="n">scalar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates all substates of a fine-structure state using a common label.</span>

<span class="sd">    :param freq_0: The energetic position of the state without the hyperfine structure or the magnetic field (MHz).</span>
<span class="sd">    :param s: The electron spin quantum number S.</span>
<span class="sd">    :param l: The electronic angular momentum quantum number L.</span>
<span class="sd">    :param j: The electronic total angular momentum quantum number J.</span>
<span class="sd">    :param i: The nuclear spin quantum number I.</span>
<span class="sd">    :param hyper_const: The hyperfine-structure constants. Currently, constants up to the electric quadrupole order are</span>
<span class="sd">     supported (A, B). If &#39;hyper_const&#39; is a scalar,</span>
<span class="sd">     it is assumed to be the constant A and the other orders are 0 (MHz).</span>
<span class="sd">    :param g: The nuclear g-factor.</span>
<span class="sd">    :param label: The label of the states. The labels are used to link states via decay maps.</span>
<span class="sd">    :returns: A list of the created states.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">get_f</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_m</span><span class="p">(</span><span class="n">_f</span><span class="p">)</span> <span class="k">for</span> <span class="n">_f</span> <span class="ow">in</span> <span class="n">f</span><span class="p">]</span>
    <span class="n">fm</span> <span class="o">=</span> <span class="p">[(</span><span class="n">_f</span><span class="p">,</span> <span class="n">_m</span><span class="p">)</span> <span class="k">for</span> <span class="n">_f</span><span class="p">,</span> <span class="n">m_f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">_m</span> <span class="ow">in</span> <span class="n">m_f</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">State</span><span class="p">(</span><span class="n">freq_0</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">_f</span><span class="p">,</span> <span class="n">_m</span><span class="p">,</span> <span class="n">hyper_const</span><span class="o">=</span><span class="n">hyper_const</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">_f</span><span class="p">,</span> <span class="n">_m</span><span class="p">)</span> <span class="ow">in</span> <span class="n">fm</span><span class="p">]</span></div>


<div class="viewcode-block" id="construct_hyperfine_state"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.construct_hyperfine_state">[docs]</a><span class="k">def</span> <span class="nf">construct_hyperfine_state</span><span class="p">(</span><span class="n">freq_0</span><span class="p">:</span> <span class="n">scalar</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">scalar</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="n">scalar</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">scalar</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">scalar</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="n">scalar</span><span class="p">,</span>
                              <span class="n">hyper_const</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">scalar</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="n">scalar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates all substates of a fine-structure state using a common label.</span>

<span class="sd">    :param freq_0: The energetic position of the state without the hyperfine structure or the magnetic field (MHz).</span>
<span class="sd">    :param s: The electron spin quantum number S.</span>
<span class="sd">    :param l: The electronic angular momentum quantum number L.</span>
<span class="sd">    :param j: The electronic total angular momentum quantum number J.</span>
<span class="sd">    :param i: The nuclear spin quantum number I.</span>
<span class="sd">    :param f: The hyperfine structure total angular momentum quantum number F.</span>
<span class="sd">    :param hyper_const: The hyperfine-structure constants. Currently, constants up to the electric quadrupole order are</span>
<span class="sd">     supported (A, B). If &#39;hyper_const&#39; is a scalar,</span>
<span class="sd">     it is assumed to be the constant A and the other orders are 0 (MHz).</span>
<span class="sd">    :param g: The nuclear g-factor.</span>
<span class="sd">    :param label: The label of the states. The labels are used to link states via decay maps.</span>
<span class="sd">    :returns: A list of the created states.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">State</span><span class="p">(</span><span class="n">freq_0</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">_m</span><span class="p">,</span> <span class="n">hyper_const</span><span class="o">=</span><span class="n">hyper_const</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">_m</span> <span class="ow">in</span> <span class="n">get_m</span><span class="p">(</span><span class="n">f</span><span class="p">)]</span></div>


<div class="viewcode-block" id="DecayMap"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.DecayMap">[docs]</a><span class="k">class</span> <span class="nc">DecayMap</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class linking sets of atomic states via Einstein-A coefficients.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">scalar</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param labels: An iterable of label pairs, corresponding to atomic states which get connected.</span>
<span class="sd">        :param a: An Iterable of Einstein-A coefficients (MHz).</span>
<span class="sd">        :param instance: A pointer to an existing DecayMap instance.</span>
<span class="sd">         If this is specified, the other parameters are omitted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">instance</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">dll</span><span class="o">.</span><span class="n">decaymap_construct</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">s0</span><span class="p">,</span> <span class="n">s1</span><span class="p">),</span> <span class="n">_a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
                <span class="n">dll</span><span class="o">.</span><span class="n">decaymap_add_decay</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)),</span> <span class="n">c_char_p</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)),</span>
                                       <span class="n">c_double</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">_a</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_labels</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">decaymap_destruct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The labels used in the C++ class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">dll</span><span class="o">.</span><span class="n">decaymap_get_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span>
                 <span class="n">dll</span><span class="o">.</span><span class="n">decaymap_get_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The list of label pairs, corresponding to atomic states which get connected.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The list of Einstein-A coefficients.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vector_d_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">set_restype</span><span class="p">(</span><span class="n">dll</span><span class="o">.</span><span class="n">decaymap_get_a</span><span class="p">,</span> <span class="n">vector_d_p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">decaymap_get_a</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The number of linked sets of atomic states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">decaymap_get_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

<div class="viewcode-block" id="DecayMap.get"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.DecayMap.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_0</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">label_1</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The number of linked sets of atomic states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">decaymap_get_item</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">label_0</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)),</span> <span class="n">c_char_p</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">label_1</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)))</span></div></div>


<span class="k">def</span> <span class="nf">_gen_label_map</span><span class="p">(</span><span class="n">atom</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param atom: The atom.</span>
<span class="sd">    :returns: A dictionary with state labels as keys</span>
<span class="sd">     and an array of the indices of the states with the labels as values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;States 0 - </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">atom</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)}</span>
    <span class="n">all_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">atom</span><span class="p">]</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">all_labels</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">label_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_labels</span><span class="p">)</span> <span class="k">if</span> <span class="n">_s</span> <span class="o">==</span> <span class="n">s</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">label_map</span>


<div class="viewcode-block" id="Atom"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Atom">[docs]</a><span class="k">class</span> <span class="nc">Atom</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class representing an Atom and its inner structure.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">State</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">decay_map</span><span class="p">:</span> <span class="n">DecayMap</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mass</span><span class="p">:</span> <span class="n">scalar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param states: The states of the atom.</span>
<span class="sd">        :param decay_map: The decay map which connects the atomic states.</span>
<span class="sd">        :param mass: The mass of the atom (u).</span>
<span class="sd">        :param instance: A pointer to an existing Atom instance.</span>
<span class="sd">         If this is specified, the other parameters are omitted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">instance</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">dll</span><span class="o">.</span><span class="n">atom_construct</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">states</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">states</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">decay_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">decay_map</span> <span class="o">=</span> <span class="n">DecayMap</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decay_map</span> <span class="o">=</span> <span class="n">decay_map</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mass</span> <span class="o">=</span> <span class="n">mass</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">atom_destruct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">state</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

<div class="viewcode-block" id="Atom.update"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Atom.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the atom.</span>

<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">atom_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span> <span class="o">=</span> <span class="n">_gen_label_map</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The states of the atom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_states</span>

    <span class="nd">@states</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">State</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: The new states of the atom.</span>
<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">atom_clear_states</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_states</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">:</span>
            <span class="n">dll</span><span class="o">.</span><span class="n">atom_add_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">decay_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The decay map which connects the atomic states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decay_map</span>

    <span class="nd">@decay_map</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">decay_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">DecayMap</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: The new decay map which connects the atomic states.</span>
<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decay_map</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decay_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decay_map</span> <span class="o">=</span> <span class="n">DecayMap</span><span class="p">()</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">atom_set_decay_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mass</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The mass of the atom (u).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">atom_get_mass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@mass</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">mass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">scalar</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: The new mass of the atom (u).</span>
<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">atom_set_mass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The number of states of the atom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">atom_get_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The indices of the ground states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vector_i_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">c_size_t</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">dll</span><span class="o">.</span><span class="n">atom_get_gs_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">),</span> <span class="p">))</span>
        <span class="n">set_restype</span><span class="p">(</span><span class="n">dll</span><span class="o">.</span><span class="n">atom_get_gs</span><span class="p">,</span> <span class="n">vector_i_p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">atom_get_gs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dipoles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The dipole strengths between the atomic states in the 3 basis-components</span>
<span class="sd">         of the spherical vector basis ( sigma-, pi, sigma+ ). This can be used to calculate Rabi-frequencies by</span>
<span class="sd">         multiplying it with the square-root of a laser intensity in the corresponding polarization.</span>
<span class="sd">         The resulting array has shape (3, size, size).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">dll</span><span class="o">.</span><span class="n">atom_get_m_dipole</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_size_t</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span>
                                               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">l0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">dll</span><span class="o">.</span><span class="n">atom_get_L0</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">l1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">dll</span><span class="o">.</span><span class="n">atom_get_L1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

<div class="viewcode-block" id="Atom.get_y0"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Atom.get_y0">[docs]</a>    <span class="k">def</span> <span class="nf">get_y0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ground_state_labels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ground_state_labels: An Iterable of labels belonging to ground states.</span>
<span class="sd">        :returns: The initial population of the atom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ground_state_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ground_state_labels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="n">ground_state_labels</span><span class="p">])</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">y0</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span>
        <span class="k">return</span> <span class="n">y0</span></div>
    
<div class="viewcode-block" id="Atom.get_y0_mc"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Atom.get_y0_mc">[docs]</a>    <span class="k">def</span> <span class="nf">get_y0_mc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ground_state_labels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param n_samples: The number of samples to create.</span>
<span class="sd">        :param ground_state_labels: An Iterable of labels belonging to ground states.</span>
<span class="sd">        :returns: The initial population of the atom for the Monte-Carlo master equation solver.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ground_state_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ground_state_labels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="n">ground_state_labels</span><span class="p">])</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_samples</span> <span class="o">%</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The number of samples (</span><span class="si">{</span><span class="n">n_samples</span><span class="si">}</span><span class="s1">) must be a multiple of&#39;</span>
                             <span class="sa">f</span><span class="s1">&#39; the number of ground states (</span><span class="si">{</span><span class="n">indices</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
        <span class="n">batch</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_samples</span> <span class="o">/</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="n">y0</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">batch</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">batch</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> \
                <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">batch</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y0</span></div>

<div class="viewcode-block" id="Atom.get_state_indexes"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Atom.get_state_indexes">[docs]</a>    <span class="k">def</span> <span class="nf">get_state_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">f</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">scalar</span><span class="p">],</span> <span class="n">scalar</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param labels: The labels of the states whose indexes are to be returned.</span>
<span class="sd">        :param f: The F quantum numbers whose indexes are to be returned.</span>
<span class="sd">        :returns: The indexes corresponding to the specified labels and F quantum numbers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">f</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">f</span> <span class="ow">in</span> <span class="n">f</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atom.scattering_rate"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Atom.scattering_rate">[docs]</a>    <span class="k">def</span> <span class="nf">scattering_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho</span><span class="p">:</span> <span class="n">array_like</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">as_density_matrix</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scattering rate of the atom into the direction</span>

<span class="sd">            e_r = (sin(theta), cos(theta) * sin(phi), cos(theta) * cos(phi))</span>

<span class="sd">        where the z-axis is the quantization axis, which is either (0, 0, 1) or the B-field axis.</span>

<span class="sd">        :param rho: The density matrix of the atom. Must have the same size as the atom</span>
<span class="sd">         along the specified &#39;axis&#39; and &#39;axis&#39; + 1.</span>
<span class="sd">        :param theta: The elevation angle of detection relative to the quantization axis.</span>
<span class="sd">        :param phi: The azimuthal angle of detection relative to the quantization axis.</span>
<span class="sd">        :param as_density_matrix: Whether &#39;rho&#39; is a state vector or a density matrix.</span>
<span class="sd">        :param i: The initially excited state indexes to consider for spontaneous decay.</span>
<span class="sd">         If None, all states are considered.</span>
<span class="sd">        :param j: The final decayed state indexes to consider for spontaneous decay. If None, all states are considered.</span>
<span class="sd">        :param axis: The axis along which the population is aligned in &#39;rho&#39;.</span>
<span class="sd">        :returns: The scattering rate of the atom given the population &#39;rho&#39; (MHz or Events / s).</span>
<span class="sd">        :raises ValueError: &#39;rho&#39; must have the same size as the atom along the specified &#39;axis&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rho</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">l0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span> <span class="k">if</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">_j</span> <span class="ow">in</span> <span class="n">j</span> <span class="k">else</span> <span class="mf">0.</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)])</span>
        <span class="n">l0</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l0</span>

        <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">phi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">as_density_matrix</span><span class="p">:</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">rho</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rho</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rho</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
                    <span class="n">axes</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rho</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">axis</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">axes</span><span class="p">:</span>
                <span class="n">l0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="n">ax</span> <span class="o">+</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rho</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">axis</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">axes</span><span class="p">:</span>
                <span class="n">l0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">l0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>

            <span class="n">sr</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">l0</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">theta</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">phi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">theta</span><span class="se">\&#39;</span><span class="s1"> and </span><span class="se">\&#39;</span><span class="s1">phi</span><span class="se">\&#39;</span><span class="s1"> must either both be specified or both be None.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">as_density_matrix</span><span class="p">:</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">vector_to_diag_matrix</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">a_cart</span> <span class="o">=</span> <span class="p">[[</span><span class="n">al</span><span class="o">.</span><span class="n">a_dipole_cart</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">_j</span><span class="p">]</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">_j</span><span class="p">]</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">_j</span><span class="p">]</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">_j</span><span class="p">]</span><span class="o">.</span><span class="n">m</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
                   <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">_j</span><span class="p">]</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">_j</span><span class="p">]</span><span class="o">.</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                   <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">decay_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">_j</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
                   <span class="k">if</span> <span class="n">l0</span><span class="p">[</span><span class="n">_j</span><span class="p">,</span> <span class="n">_i</span><span class="p">]</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                   <span class="k">if</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">_j</span> <span class="ow">in</span> <span class="n">j</span> <span class="k">else</span> <span class="mf">0.</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">e_theta</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">e_theta</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
        <span class="n">e_phi</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">e_phi</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>

        <span class="n">c_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">e_theta</span> <span class="o">*</span> <span class="n">_a_cart</span><span class="p">)</span> <span class="k">for</span> <span class="n">_a_cart</span> <span class="ow">in</span> <span class="n">a_cart_list</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">a_cart_list</span> <span class="ow">in</span> <span class="n">a_cart</span><span class="p">])</span>
        <span class="n">c_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">e_phi</span> <span class="o">*</span> <span class="n">_a_cart</span><span class="p">)</span> <span class="k">for</span> <span class="n">_a_cart</span> <span class="ow">in</span> <span class="n">a_cart_list</span><span class="p">]</span>
                          <span class="k">for</span> <span class="n">a_cart_list</span> <span class="ow">in</span> <span class="n">a_cart</span><span class="p">])</span>

        <span class="n">ct_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">e_theta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">_a_cart</span><span class="p">))</span>
                              <span class="k">for</span> <span class="n">_a_cart</span> <span class="ow">in</span> <span class="n">a_cart_list</span><span class="p">]</span> <span class="k">for</span> <span class="n">a_cart_list</span> <span class="ow">in</span> <span class="n">a_cart</span><span class="p">])</span>
        <span class="n">ct_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">e_phi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">_a_cart</span><span class="p">))</span>
                            <span class="k">for</span> <span class="n">_a_cart</span> <span class="ow">in</span> <span class="n">a_cart_list</span><span class="p">]</span> <span class="k">for</span> <span class="n">a_cart_list</span> <span class="ow">in</span> <span class="n">a_cart</span><span class="p">])</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">axis</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">c_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">c_theta</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
            <span class="n">c_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">c_phi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
            <span class="n">ct_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">ct_theta</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
            <span class="n">ct_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">ct_phi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="n">ax</span> <span class="o">+</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rho</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">axis</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">c_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">c_theta</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
            <span class="n">c_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">c_phi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
            <span class="n">ct_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">ct_theta</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
            <span class="n">ct_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">ct_phi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>

        <span class="n">sr</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">tools</span><span class="o">.</span><span class="n">get_subarray</span><span class="p">(</span><span class="n">c_theta</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                      <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">tools</span><span class="o">.</span><span class="n">get_subarray</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
              <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">tools</span><span class="o">.</span><span class="n">get_subarray</span><span class="p">(</span><span class="n">ct_theta</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">tools</span><span class="o">.</span><span class="n">get_subarray</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        
        <span class="n">sr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">tools</span><span class="o">.</span><span class="n">get_subarray</span><span class="p">(</span><span class="n">c_phi</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                       <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">tools</span><span class="o">.</span><span class="n">get_subarray</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
               <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">tools</span><span class="o">.</span><span class="n">get_subarray</span><span class="p">(</span><span class="n">ct_phi</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                         <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">tools</span><span class="o">.</span><span class="n">get_subarray</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="mi">3</span> <span class="o">/</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">real</span></div>

<div class="viewcode-block" id="Atom.plot"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Atom.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">draw_bounds</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">show</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a term scheme of the atom.</span>

<span class="sd">        :param indices: The indices of the states to be drawn. If None, all states are drawn.</span>
<span class="sd">        :param draw_bounds: Whether to draw the upper vertical bounds of the states.</span>
<span class="sd">        :param show: Whether to show the plot.</span>
<span class="sd">        :returns: The x and y positions of the states as well as the distance constant d.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">([</span><span class="n">state</span><span class="o">.</span><span class="n">freq</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">])</span>
        <span class="n">d</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">y_i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">y_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">m_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">m</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>
        <span class="n">ret_x</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ret_y</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">y_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">key_1</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">key_1</span> <span class="ow">in</span> <span class="n">y_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()]:</span>
                    <span class="n">y_i</span> <span class="o">+=</span> <span class="mi">3</span>
                <span class="n">y_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_i</span> <span class="o">*</span> <span class="n">d</span>
                <span class="n">y_i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">draw_bounds</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">hlines</span><span class="p">([</span><span class="n">y_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">y_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.95</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span>
                               <span class="n">xmin</span><span class="o">=-</span><span class="n">m_max</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="n">m_max</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mf">0.45</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">m</span> <span class="o">+</span> <span class="mf">0.45</span><span class="p">])</span>  <span class="c1"># + x_off[key[:-1]]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y_dict</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">y_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]])</span>
            <span class="n">ret_x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">ret_y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">)</span>

        <span class="n">x_ticks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">m_max</span><span class="p">,</span> <span class="n">m_max</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">m_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">x_ticks</span><span class="p">)</span>
        <span class="n">y_ticks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">_y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">_y</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">_y</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span> <span class="k">for</span> <span class="n">_y</span> <span class="ow">in</span> <span class="n">y_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">y_ticks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">y_ticks</span> <span class="o">=</span> <span class="n">y_ticks</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">y_ticks</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">y_l</span><span class="p">)</span> <span class="k">for</span> <span class="n">y_l</span> <span class="ow">in</span> <span class="n">y_ticks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$m$&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$(\mathrm</span><span class="si">{label}</span><span class="s1">, F)$&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ret_x</span><span class="p">,</span> <span class="n">ret_y</span><span class="p">,</span> <span class="n">d</span></div></div>


<span class="k">def</span> <span class="nf">_cast_t</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">t</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">t_size</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span>
    <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All times </span><span class="se">\&#39;</span><span class="s1">t</span><span class="se">\&#39;</span><span class="s1"> must be positive.&#39;</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="n">t</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">t_size</span> <span class="o">!=</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span>


<span class="k">def</span> <span class="nf">_cast_delta</span><span class="p">(</span><span class="n">delta</span><span class="p">:</span> <span class="n">array_like</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param delta: An array of frequency shifts for the laser(s). &#39;delta&#39; must be a scalar or a 1d- or 2d-array</span>
<span class="sd">     with shapes (., ) or (., #lasers), respectively.</span>
<span class="sd">    :param m: The index of the shifted laser. If delta is a 2d-array, &#39;m&#39; ist omitted.</span>
<span class="sd">    :param size: The number of available lasers.</span>
<span class="sd">    :returns: An array of vectors with size &#39;size&#39; containing frequency shifts for the lasers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">delta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="o">-</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Laser index </span><span class="se">\&#39;</span><span class="s1">m</span><span class="se">\&#39;</span><span class="s1"> is out of bounds. Must be </span><span class="si">{}</span><span class="s1"> &lt;= m &lt; </span><span class="si">{}</span><span class="s1"> or None but is </span><span class="si">{}</span><span class="s1">.&#39;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">-</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
    <span class="n">error</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">error</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">delta</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">tools</span><span class="o">.</span><span class="n">unit_vector</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">delta</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">unit_vector</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> \
                    <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">delta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">size</span><span class="p">:</span>
        <span class="n">error</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">error</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">delta</span><span class="se">\&#39;</span><span class="s1"> must be a scalar or a 1d- or 2d-array with shapes &#39;</span>
                         <span class="s1">&#39;(., ) or (., #lasers), respectively.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">delta</span>


<span class="k">def</span> <span class="nf">_cast_y0</span><span class="p">(</span><span class="n">y0</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">array_like</span><span class="p">],</span> <span class="n">i_solver</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">atom</span><span class="p">:</span> <span class="n">Atom</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param y0: The initial states of an ensemble of n atoms. Depending on the solver, this must have shape</span>
<span class="sd">     i_solver = 0 and 1: (#states, ) or (n, #states).</span>
<span class="sd">     i_solver = 2: (#states, ), (n, #states) or (n, #states, #states).</span>
<span class="sd">    :param i_solver: The index of the solver.</span>
<span class="sd">    :param atom: The atom.</span>
<span class="sd">    :returns: The correctly shaped &#39;y0&#39; for the chosen solver and its C type.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">size</span>
    <span class="n">gs</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">gs</span>

    <span class="k">if</span> <span class="n">i_solver</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Rate equations.</span>
        <span class="k">if</span> <span class="n">y0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">y0</span><span class="p">[</span><span class="n">gs</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">gs</span><span class="o">.</span><span class="n">size</span>
            <span class="k">return</span> <span class="n">y0</span><span class="p">,</span> <span class="n">c_double_p</span>

        <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">y0</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">y0</span><span class="se">\&#39;</span><span class="s1"> must have size </span><span class="si">{}</span><span class="s1"> in the last axis but has shape </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># Add the missing sample axis.</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># Flatten all but the last axis.</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">y0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="n">y0</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">dtype</span><span class="p">,</span> <span class="n">pointer</span> <span class="o">=</span> <span class="nb">float</span><span class="p">,</span> <span class="n">c_double_p</span>

    <span class="k">elif</span> <span class="n">i_solver</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Schroedinger equation / MC master.</span>
        <span class="k">if</span> <span class="n">y0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">y0</span><span class="p">[</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">y0</span><span class="p">,</span> <span class="n">c_complex_p</span>

        <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">y0</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">y0</span><span class="se">\&#39;</span><span class="s1"> must have size </span><span class="si">{}</span><span class="s1"> in the last axis but has shape </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># Add the missing sample axis.</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># Flatten all but the last axis.</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">y0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="n">y0</span> <span class="o">/=</span> <span class="n">tools</span><span class="o">.</span><span class="n">absolute_complex</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># Normalize</span>
        <span class="n">dtype</span><span class="p">,</span> <span class="n">pointer</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">c_complex_p</span>

    <span class="k">elif</span> <span class="n">i_solver</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># Master equation.</span>
        <span class="k">if</span> <span class="n">y0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">y0</span><span class="p">[</span><span class="n">gs</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">gs</span><span class="o">.</span><span class="n">size</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">y0</span><span class="p">),</span> <span class="n">c_complex_p</span>

        <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">y0</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span> \
                <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">!=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">y0</span><span class="se">\&#39;</span><span class="s1"> must have size </span><span class="si">{}</span><span class="s1"> in the last axis if len(y0.shape) &lt;= 2,&#39;</span>
                             <span class="s1">&#39; or shape </span><span class="si">{}</span><span class="s1"> in the last two axes if len(y0.shape) &gt; 2.&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># Normalize and create n diagonal matrices.</span>
            <span class="n">y0</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">_y0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_y0</span> <span class="ow">in</span> <span class="n">y0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># Flatten all but the last two axes and normalize.</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span> <span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">y0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="n">y0</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Normalize and add the missing sample axis.</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">y0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y0</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dtype</span><span class="p">,</span> <span class="n">pointer</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">c_complex_p</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Solver &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i_solver</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; not available </span><span class="se">\&#39;</span><span class="s1">i_solver</span><span class="se">\&#39;</span><span class="s1"> must be in {0, 1, 2}.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="n">pointer</span>


<span class="k">def</span> <span class="nf">_cast_v</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">array_like</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param v: Atom velocities. Must be a scalar or have shape (n, ) or (n, 3). In the first two cases,</span>
<span class="sd">     the velocity vector(s) is assumed to be aligned with the x-axis.</span>
<span class="sd">    :returns: The correctly shaped velocities with shape (n, 3).</span>
<span class="sd">    :raises ValueError: If &#39;v&#39; has the wrong shape.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">ret</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">v</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">v</span><span class="se">\&#39;</span><span class="s1"> must be a scalar or have shape (n, ) or (n, 3) but has shape </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    

<div class="viewcode-block" id="Interaction"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Interaction">[docs]</a><span class="k">class</span> <span class="nc">Interaction</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class representing an Interaction between lasers and an atom.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">:</span> <span class="n">Atom</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lasers</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Laser</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">delta_max</span><span class="p">:</span> <span class="n">scalar</span> <span class="o">=</span> <span class="mf">1e3</span><span class="p">,</span>
                 <span class="n">controlled</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param atom: The atom.</span>
<span class="sd">        :param lasers: The lasers.</span>
<span class="sd">        :param delta_max: The maximum absolute difference between a laser and a transition frequency</span>
<span class="sd">         for that transition to be considered laser-driven (MHz). The default value is 1 GHz.</span>
<span class="sd">        :param controlled: Whether the ODE solver uses an error controlled stepper or a fixed step size.</span>
<span class="sd">         Setting this to True is particularly useful for dynamics where a changing resolution is required.</span>
<span class="sd">         However, this comes at the cost of computing time.</span>
<span class="sd">        :param instance: A pointer to an existing Interaction instance.</span>
<span class="sd">         If this is specified, the other parameters are omitted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">instance</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">dll</span><span class="o">.</span><span class="n">interaction_construct</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_environment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_environemnt</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">atom</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">lasers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lasers</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="n">atom</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lasers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lasers</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta_max</span> <span class="o">=</span> <span class="n">delta_max</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">controlled</span> <span class="o">=</span> <span class="n">controlled</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_environment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_environemnt</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_atom</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lasers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lasers</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">interaction_destruct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_environemnt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: The environment used in the C++ class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Environment</span><span class="p">(</span><span class="n">instance</span><span class="o">=</span><span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_environment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: The atom used in the C++ class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Atom</span><span class="p">(</span><span class="n">instance</span><span class="o">=</span><span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_lasers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The lasers used in the C++ class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Laser</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_laser</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_lasers_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">))]</span>

<div class="viewcode-block" id="Interaction.update"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Interaction.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the Interaction.</span>

<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">interaction_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span></div>

<div class="viewcode-block" id="Interaction.resonance_info"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Interaction.resonance_info">[docs]</a>    <span class="k">def</span> <span class="nf">resonance_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints the detunings of the base frequencies of the lasers in the given atomic system.</span>
<span class="sd">        In particular useful for systems with a hyperfine structure. Here</span>

<span class="sd">        .. math:: \\Delta = \\nu_0 - \\nu_L.</span>

<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Resonance info:&#39;</span><span class="p">)</span>  <span class="c1"># \n&lt;label&gt;(S, L, J, I, F, m) -&gt; &lt;label\&#39;&gt;(S\&#39;, L\&#39;, J\&#39;, I\&#39;, F\&#39;, m\&#39;)&#39;)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">laser</span><span class="p">,</span> <span class="n">laser_m</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lasers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rabi</span><span class="p">())):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Laser </span><span class="si">{}</span><span class="s1"> @ </span><span class="si">{}</span><span class="s1"> MHz:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">laser</span><span class="o">.</span><span class="n">freq</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">state_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">state_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">laser_m</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">state_i</span><span class="o">.</span><span class="n">freq</span> <span class="o">&lt;</span> <span class="n">state_j</span><span class="o">.</span><span class="n">freq</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> -&gt; </span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1"> MHz&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">state_i</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">state_j</span><span class="p">),</span>
                                                            <span class="n">state_j</span><span class="o">.</span><span class="n">freq</span> <span class="o">-</span> <span class="n">state_i</span><span class="o">.</span><span class="n">freq</span> <span class="o">-</span> <span class="n">laser</span><span class="o">.</span><span class="n">freq</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> -&gt; </span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1"> MHz&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">state_j</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">state_i</span><span class="p">),</span>
                                                            <span class="n">state_i</span><span class="o">.</span><span class="n">freq</span> <span class="o">-</span> <span class="n">state_j</span><span class="o">.</span><span class="n">freq</span> <span class="o">-</span> <span class="n">laser</span><span class="o">.</span><span class="n">freq</span><span class="p">))</span>
                        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No resonances!&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">environment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The environment of the interaction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_environment</span>

    <span class="nd">@environment</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">environment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Environment</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: The new environment of the interaction.</span>
<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_environment</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">interaction_set_environment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The atom of the interaction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atom</span>

    <span class="nd">@atom</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Atom</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: The new atom of the interaction.</span>
<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atom</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">interaction_set_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lasers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The lasers of the interaction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lasers</span>

    <span class="nd">@lasers</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">lasers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Laser</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: The new lasers of the interaction.</span>
<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lasers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">interaction_clear_lasers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">laser</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasers</span><span class="p">:</span>
            <span class="n">dll</span><span class="o">.</span><span class="n">interaction_add_laser</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">laser</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">delta_max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The maximum absolute difference between a laser and a transition frequency</span>
<span class="sd">         for that transition to be considered laser-driven (MHz). The default value is 1 GHz.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_delta_max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@delta_max</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">delta_max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">scalar</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: The new maximum absolute difference between a laser and a transition frequency</span>
<span class="sd">         for that transition to be considered laser-driven (MHz). The default value is 1 GHz.</span>
<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">interaction_set_delta_max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">controlled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: Whether the ODE solver uses an error controlled stepper or a fixed step size.</span>
<span class="sd">         Setting this to True is particularly useful for dynamics where a changing resolution is required.</span>
<span class="sd">         However, this comes at the cost of computing time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_controlled</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@controlled</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">controlled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: Whether the ODE solver uses an error controlled stepper or a fixed step size.</span>
<span class="sd">         Setting this to True is particularly useful for dynamics where a changing resolution is required.</span>
<span class="sd">         However, this comes at the cost of computing time.</span>
<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">interaction_set_controlled</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_bool</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dense</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: Whether the ODE solver uses an error controlled dense output stepper.</span>
<span class="sd">         If True, this overrides the controlled flag.</span>
<span class="sd">         Setting this to True is particularly useful for dynamics where a changing resolution is required.</span>
<span class="sd">         However, this comes at the cost of computing time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_dense</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@dense</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dense</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: Whether the ODE solver uses an error controlled dense output stepper.</span>
<span class="sd">         If True, this overrides the controlled flag.</span>
<span class="sd">         Setting this to True is particularly useful for dynamics where a changing resolution is required.</span>
<span class="sd">         However, this comes at the cost of computing time.</span>
<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">interaction_set_dense</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_bool</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The (initial) step size of (controlled) solvers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_dt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@dt</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">scalar</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: The (initial) step size of (controlled) solvers.</span>
<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">interaction_set_dt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dt_max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The maximum step size of controlled solvers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_dt_max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@dt_max</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dt_max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">scalar</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: The maximum step size of controlled solvers.</span>
<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">interaction_set_dt_max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The absolute error tolerance of controlled solver.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_atol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@atol</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">atol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">scalar</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: The absolute error tolerance of controlled solver.</span>
<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">interaction_set_atol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rtol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The relative error tolerance of controlled solver.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_rtol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@rtol</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">rtol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">scalar</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: The relative error tolerance of controlled solver.</span>
<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">interaction_set_rtol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: Whether there are loops formed by the lasers in the atom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_loop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time_dependent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: Whether the system hamiltonian is allowed to be time dependent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_time_dependent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@time_dependent</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">time_dependent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: Set whether the system hamiltonian is allowed to be time dependent.</span>
<span class="sd">        :returns: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">interaction_set_time_dependent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_bool</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

<div class="viewcode-block" id="Interaction.get_rabi"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Interaction.get_rabi">[docs]</a>    <span class="k">def</span> <span class="nf">get_rabi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param m: The laser number &#39;m&#39;. If None, the Rabi frequencies are returned for all lasers</span>
<span class="sd">         as an array with shape (#lasers, atom.size, atom.size).</span>
<span class="sd">        :returns: The Rabi frequencies (generated by the laser &#39;m&#39;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix_cd_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="n">set_restype</span><span class="p">(</span><span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_rabi</span><span class="p">,</span> <span class="n">matrix_cd_p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_rabi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_size_t</span><span class="p">(</span><span class="n">_m</span><span class="p">))</span>
                             <span class="k">for</span> <span class="n">_m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lasers</span><span class="p">))],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_rabi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">c_size_t</span><span class="p">(</span><span class="n">m</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">summap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: A (atom.size x atom.size)-matrix indicating the states which are laser-connected.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix_i_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="n">set_restype</span><span class="p">(</span><span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_summap</span><span class="p">,</span> <span class="n">matrix_i_p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_summap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atommap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: A projection matrix A mapping the state frequencies onto the diagonal of the Hamiltonian.</span>
<span class="sd">         It holds diag(H)_i &lt;- sum_j(A_ij * state_j.freq).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix_d_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="n">set_restype</span><span class="p">(</span><span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_atommap</span><span class="p">,</span> <span class="n">matrix_d_p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_atommap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">deltamap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: A projection matrix B mapping the laser frequencies onto the diagonal of the Hamiltonian.</span>
<span class="sd">         It holds diag(H)_i &lt;- sum_j(B_im * laser_m.freq).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix_d_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lasers</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="n">set_restype</span><span class="p">(</span><span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_deltamap</span><span class="p">,</span> <span class="n">matrix_d_p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_deltamap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

<div class="viewcode-block" id="Interaction.get_delta"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Interaction.get_delta">[docs]</a>    <span class="k">def</span> <span class="nf">get_delta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">vector_d_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">set_restype</span><span class="p">(</span><span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_delta</span><span class="p">,</span> <span class="n">vector_d_p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_delta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">history_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The length of the history of states visited during the generation of the diagonal maps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_n_history</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">history</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The history of states visited during the generation of the diagonal maps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vector_i_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">c_size_t</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">history_size</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">set_restype</span><span class="p">(</span><span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_history</span><span class="p">,</span> <span class="n">vector_i_p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_history</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>

<div class="viewcode-block" id="Interaction.hamiltonian"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Interaction.hamiltonian">[docs]</a>    <span class="k">def</span> <span class="nf">hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">array_like</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param t: The times when to compute the solution.</span>
<span class="sd">        :param delta: An array of frequency shifts for the laser(s). &#39;delta&#39; must be a scalar or a 1d- or 2d-array</span>
<span class="sd">         with shapes (n, ) or (n, #lasers), respectively.</span>
<span class="sd">        :param m: The index of the shifted laser. If delta is a 2d-array, &#39;m&#39; ist omitted.</span>
<span class="sd">        :param v: Atom velocities. Must be a scalar or have shape (n, ) or (n, 3). In the first two cases,</span>
<span class="sd">         the velocity vector(s) are assumed to be aligned with the x-axis.</span>
<span class="sd">        :returns: The integrated master equation as a complex-valued array of shape (n, #states, #states, #times).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">t_size</span><span class="p">,</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">_cast_t</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">delta</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">delta</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span><span class="p">:</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">sample_size</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">_cast_delta</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lasers</span><span class="p">))</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">_cast_v</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

            <span class="n">sample_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">delta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>

            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lasers</span><span class="p">))),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sample_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">t_size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">interaction_get_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_double_p</span><span class="p">),</span> <span class="n">delta</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_double_p</span><span class="p">),</span>
                                        <span class="n">v</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_double_p</span><span class="p">),</span> <span class="n">results</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_complex_p</span><span class="p">),</span>
                                        <span class="n">c_size_t</span><span class="p">(</span><span class="n">t_size</span><span class="p">),</span> <span class="n">c_size_t</span><span class="p">(</span><span class="n">sample_size</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">ex</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">results</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Interaction.rates"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Interaction.rates">[docs]</a>    <span class="k">def</span> <span class="nf">rates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">array_like</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
              <span class="n">y0</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solver for the rate equations. Solutions for n samples can be calculated in parallel.</span>

<span class="sd">        :param t: The times when to compute the solution (us).</span>
<span class="sd">        :param delta: An array of frequency shifts for the laser(s) (MHz).</span>
<span class="sd">         &#39;delta&#39; must be a scalar or a 1d- or 2d-array with shapes (n, ) or (n, #lasers), respectively.</span>
<span class="sd">        :param m: The index of the shifted laser. If delta is a 2d-array, &#39;m&#39; ist omitted.</span>
<span class="sd">        :param v: Atom velocities (m/s). Must be a scalar or have shape (n, ) or (n, 3). In the first two cases,</span>
<span class="sd">         the velocity vector(s) is(are) assumed to be aligned with the x-axis.</span>
<span class="sd">        :param y0: The initial state of the atom. This must be None or have shape (#states, ) or (n, #states).</span>
<span class="sd">         If None, the ground states are populated equally.</span>
<span class="sd">        :returns: The integrated rate equations as a real-valued array of shape (n, #states, #times).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">t_size</span><span class="p">,</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">_cast_t</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">delta</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">delta</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span><span class="p">:</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">y0</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span><span class="p">:</span>
                    <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">y0</span><span class="p">)</span>
            <span class="n">sample_size</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">_cast_delta</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lasers</span><span class="p">))</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">_cast_v</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">y0</span><span class="p">,</span> <span class="n">ctype</span> <span class="o">=</span> <span class="n">_cast_y0</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">)</span>

            <span class="n">sample_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">delta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>

            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lasers</span><span class="p">))),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sample_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">t_size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">interaction_rates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_double_p</span><span class="p">),</span> <span class="n">delta</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_double_p</span><span class="p">),</span>
                              <span class="n">v</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_double_p</span><span class="p">),</span> <span class="n">y0</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_double_p</span><span class="p">),</span>
                              <span class="n">results</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_double_p</span><span class="p">),</span> <span class="n">c_size_t</span><span class="p">(</span><span class="n">t_size</span><span class="p">),</span> <span class="n">c_size_t</span><span class="p">(</span><span class="n">sample_size</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">ex</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">results</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Interaction.schroedinger"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Interaction.schroedinger">[docs]</a>    <span class="k">def</span> <span class="nf">schroedinger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">array_like</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">y0</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solver for the Schroedinger equation. Solutions for n samples can be calculated in parallel.</span>

<span class="sd">        :param t: The times when to compute the solution (us).</span>
<span class="sd">        :param delta: An array of frequency shifts for the laser(s) (MHz).</span>
<span class="sd">         &#39;delta&#39; must be a scalar or a 1d- or 2d-array with shapes (n, ) or (n, #lasers), respectively.</span>
<span class="sd">        :param m: The index of the shifted laser. If delta is a 2d-array, &#39;m&#39; ist omitted.</span>
<span class="sd">        :param v: Atom velocities (m/s). Must be a scalar or have shape (n, ) or (n, 3). In the first two cases,</span>
<span class="sd">         the velocity vector(s) is(are) assumed to be aligned with the x-axis.</span>
<span class="sd">        :param y0: The initial state of the atom. This must be None or have shape (n, #states).</span>
<span class="sd">         If None, only the first ground state is populated.</span>
<span class="sd">        :returns: The integrated Schroedinger equation as a complex-valued array of shape (n, #states, #times).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">t_size</span><span class="p">,</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">_cast_t</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">delta</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">delta</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span><span class="p">:</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">y0</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span><span class="p">:</span>
                    <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">y0</span><span class="p">)</span>
            <span class="n">sample_size</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">_cast_delta</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lasers</span><span class="p">))</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">_cast_v</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">y0</span><span class="p">,</span> <span class="n">ctype</span> <span class="o">=</span> <span class="n">_cast_y0</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">)</span>

            <span class="n">sample_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">delta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>

            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lasers</span><span class="p">))),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sample_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">t_size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">interaction_schroedinger</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_double_p</span><span class="p">),</span> <span class="n">delta</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_double_p</span><span class="p">),</span>
                                     <span class="n">v</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_double_p</span><span class="p">),</span> <span class="n">y0</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_complex_p</span><span class="p">),</span>
                                     <span class="n">results</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_complex_p</span><span class="p">),</span> <span class="n">c_size_t</span><span class="p">(</span><span class="n">t_size</span><span class="p">),</span> <span class="n">c_size_t</span><span class="p">(</span><span class="n">sample_size</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">ex</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">results</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Interaction.master"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Interaction.master">[docs]</a>    <span class="k">def</span> <span class="nf">master</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">array_like</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
               <span class="n">y0</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solver for the master equation. Solutions for n samples can be calculated in parallel.</span>

<span class="sd">        :param t: The times when to compute the solution (us).</span>
<span class="sd">        :param delta: An array of frequency shifts for the laser(s) (MHz).</span>
<span class="sd">         &#39;delta&#39; must be a scalar or a 1d- or 2d-array with shapes (n, ) or (n, #lasers), respectively.</span>
<span class="sd">        :param m: The index of the shifted laser. If delta is a 2d-array, &#39;m&#39; ist omitted.</span>
<span class="sd">        :param v: Atom velocities (m/s). Must be a scalar or have shape (n, ) or (n, 3). In the first two cases,</span>
<span class="sd">         the velocity vector(s) is(are) assumed to be aligned with the x-axis.</span>
<span class="sd">        :param y0: The initial state / density matrix of the atom.</span>
<span class="sd">         This must be None or have shape (#states, ), (n or 1, #states) or (n or 1, #states, #states).</span>
<span class="sd">         If #states == n, it is interpreted as (n, #states). If None, the ground states are populated equally.</span>
<span class="sd">        :returns: The integrated master equation as a complex-valued array of shape (n, #states, #states, #times).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">t_size</span><span class="p">,</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">_cast_t</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">delta</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">delta</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span><span class="p">:</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">y0</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span><span class="p">:</span>
                    <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">y0</span><span class="p">)</span>
            <span class="n">sample_size</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">_cast_delta</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lasers</span><span class="p">))</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">_cast_v</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">y0</span><span class="p">,</span> <span class="n">ctype</span> <span class="o">=</span> <span class="n">_cast_y0</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">)</span>

            <span class="n">sample_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">delta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>

            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lasers</span><span class="p">))),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sample_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">t_size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">interaction_master</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_double_p</span><span class="p">),</span> <span class="n">delta</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_double_p</span><span class="p">),</span>
                               <span class="n">v</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_double_p</span><span class="p">),</span> <span class="n">y0</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_complex_p</span><span class="p">),</span>
                               <span class="n">results</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_complex_p</span><span class="p">),</span> <span class="n">c_size_t</span><span class="p">(</span><span class="n">t_size</span><span class="p">),</span> <span class="n">c_size_t</span><span class="p">(</span><span class="n">sample_size</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">ex</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">results</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Interaction.mc_master"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Interaction.mc_master">[docs]</a>    <span class="k">def</span> <span class="nf">mc_master</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">array_like</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">y0</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dynamics</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">ntraj</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> <span class="n">as_density_matrix</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solver for the Monte-Carlo master equation. Solutions for n samples can be calculated in parallel.</span>

<span class="sd">        :param t: The times when to compute the solution (us).</span>
<span class="sd">        :param delta: An array of frequency shifts for the laser(s) (MHz).</span>
<span class="sd">         &#39;delta&#39; must be a scalar or a 1d- or 2d-array with shapes (n, ) or (n, #lasers), respectively.</span>
<span class="sd">        :param m: The index of the shifted laser. If delta is a 2d-array, &#39;m&#39; ist omitted.</span>
<span class="sd">        :param v: Atom velocities (m/s). Must be a scalar or have shape (n, ) or (n, 3). In the first two cases,</span>
<span class="sd">         the velocity vector(s) is(are) assumed to be aligned with the x-axis.</span>
<span class="sd">        :param y0: The initial state of the atom. This must be None or have shape (n, #states).</span>
<span class="sd">         If None, only the first ground state is populated.</span>
<span class="sd">        :param dynamics: Whether to compute the dynamics of the photon-atom interactions.</span>
<span class="sd">        :param ntraj: The number of samples to compute if no samples were given with &#39;delta&#39;, &#39;v&#39;, or &#39;y0&#39;.</span>
<span class="sd">        :param as_density_matrix: Whether the result is returned as density matrices or as state vectors.</span>
<span class="sd">        :returns: The integrated MC-Schroedinger equation as a complex-valued array of shape (n, #states, #times).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">controlled</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Controlled or Dense steppers are not supported for </span><span class="se">\&#39;</span><span class="s1">master_mc</span><span class="se">\&#39;</span><span class="s1">.&#39;</span>
                             <span class="s1">&#39; Decrease the step size if necessary.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dynamics</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">mass</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;To simulate mechanical dynamics, the mass of the atom must be specified.&#39;</span><span class="p">)</span>

        <span class="n">t</span><span class="p">,</span> <span class="n">t_size</span><span class="p">,</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">_cast_t</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">delta</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">delta</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span><span class="p">:</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">y0</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span><span class="p">:</span>
                    <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">y0</span><span class="p">)</span>
            <span class="n">sample_size</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">_cast_delta</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lasers</span><span class="p">))</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">_cast_v</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">y0</span><span class="p">,</span> <span class="n">ctype</span> <span class="o">=</span> <span class="n">_cast_y0</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">)</span>

            <span class="n">sample_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">delta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">sample_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sample_size</span> <span class="o">=</span> <span class="n">ntraj</span>

            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lasers</span><span class="p">))),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sample_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">t_size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">dll</span><span class="o">.</span><span class="n">interaction_mc_master</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_double_p</span><span class="p">),</span> <span class="n">delta</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_double_p</span><span class="p">),</span>
                                  <span class="n">v</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_double_p</span><span class="p">),</span> <span class="n">y0</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_complex_p</span><span class="p">),</span> <span class="n">c_bool</span><span class="p">(</span><span class="n">dynamics</span><span class="p">),</span>
                                  <span class="n">results</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">c_complex_p</span><span class="p">),</span> <span class="n">c_size_t</span><span class="p">(</span><span class="n">t_size</span><span class="p">),</span> <span class="n">c_size_t</span><span class="p">(</span><span class="n">sample_size</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">ex</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">results</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>

        <span class="k">if</span> <span class="n">as_density_matrix</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">results</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">results</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">results</span><span class="p">,</span> <span class="n">v</span></div>

<div class="viewcode-block" id="Interaction.scattering_rate"><a class="viewcode-back" href="../../../qspec.html#qspec.simulate.Interaction.scattering_rate">[docs]</a>    <span class="k">def</span> <span class="nf">scattering_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho</span><span class="p">:</span> <span class="n">array_like</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">as_density_matrix</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">array_like</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scattering rate of the atom into the direction</span>

<span class="sd">            e_r = (sin(theta), cos(theta) * sin(phi), cos(theta) * cos(phi))</span>

<span class="sd">        where the z-axis is the quantization axis, which is either (0, 0, 1) or the B-field axis.</span>

<span class="sd">        :param rho: The density matrix of the atom. Must have the same size as the atom</span>
<span class="sd">         along the specified &#39;axis&#39; and &#39;axis&#39; + 1.</span>
<span class="sd">        :param theta: The elevation angle of detection relative to the quantization axis.</span>
<span class="sd">        :param phi: The azimuthal angle of detection relative to the quantization axis.</span>
<span class="sd">        :param as_density_matrix: Whether &#39;rho&#39; is a state vector or a density matrix.</span>
<span class="sd">        :param i: The initially excited state indexes to consider for spontaneous decay.</span>
<span class="sd">         If None, all states are considered.</span>
<span class="sd">        :param j: The final decayed state indexes to consider for spontaneous decay. If None, all states are considered.</span>
<span class="sd">        :param axis: The axis along which the population is aligned in &#39;rho&#39;.</span>
<span class="sd">        :returns: The scattering rate of the atom given the population &#39;rho&#39; (MHz or Events / s).</span>
<span class="sd">        :raises ValueError: &#39;rho&#39; must have the same size as the atom along the specified &#39;axis&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">scattering_rate</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">,</span> <span class="n">as_density_matrix</span><span class="o">=</span><span class="n">as_density_matrix</span><span class="p">,</span>
                                         <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">_define_colors</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">label_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">colormap</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param n: The size of the system.</span>
<span class="sd">    :param label_map: A dictionary with state labels as keys</span>
<span class="sd">     and an array of the indices of the states with the labels as values.</span>
<span class="sd">    :param colormap: A matplotlib colormap.</span>
<span class="sd">    :returns: A list of colors with size n.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cmap</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">colormap</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">label_map</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">kv</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="n">kv</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">colormap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">colors</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">COLORS</span><span class="o">.</span><span class="n">PYPLOT</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="mi">10</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">colors</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">colors</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Patrick Mueller.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>